#!/usr/bin/env python
# -*- coding: utf-8 -*-

import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

import argparse
import os
import yaml
import json
import pytz
import sys
from datetime import datetime, timedelta

import random
from random import randrange
from pathlib import Path

import socket
import multiprocessing

from pymisp import ExpandedPyMISP, MISPEvent, MISPTag

from pymongo import MongoClient
from utils import get_settings, extract_urls
from analyzer import detect_action

settings = get_settings()

def get_lock(process_name):
    #https://stackoverflow.com/questions/788411/check-to-see-if-python-script-is-running

    # Without holding a reference to our socket somewhere it gets garbage
    # collected when the function exits
    get_lock._lock_socket = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM)

    try:
        # The null byte (\0) means the the socket is created 
        # in the abstract namespace instead of being created 
        # on the file system itself.
        # Works only in Linux
        get_lock._lock_socket.bind('\0' + process_name)
        print ('I got the lock')
    except socket.error:
        print ('lock exists')
        sys.exit()

def call_with_timeout(func, args, kwargs, timeout):

    #for LINUX only
    manager = multiprocessing.Manager()
    return_dict = manager.dict()
    #define a wrapper of 'return dict' to store the results
    def function(return_dict):
        return_dict['value'] = func(*args, **kwargs)
    p = multiprocessing.Process(target=function, args=(return_dict,))
    p.start()
    #Force a max 'timeout' or wait for the process to finish
    p.join(timeout)
    #If thread is still active, it didn't finish: raise TimeoutError
    if p.is_alive():
        p.terminate()
        p.join()
        raise TimeoutError
    else:
        return return_dict.get('value')

def get_misp_event(misp, event_name):
    event = misp.search(eventinfo=event_name)

    if not event:
        event = MISPEvent()
        event.distribution = 3
        event.threat_level_id = 4
        event.analysis = 2
        event.info = event_name
        event.add_tag('AutoGenerated')
        event.add_tag('honeypot-basic:interaction-level="high"')
        event = misp.add_event(event, pythonify=True)
        return event
    else:
        return event[0]['Event']

def export_as_json_feed(misp, event_name, outputdir):
    events = misp.search(eventinfo=event_name, published=True)
    if len(events) == 0:
        sys.exit("No events returned.")

    event = events[0]['Event']

    manifest = {}
    hashes = []

    e = misp.get_event(event['uuid'], deleted=False, pythonify=True)
    e_feed = e.to_feed(valid_distributions=[0, 1, 2, 3, 4, 5], with_meta=True)

    hashes += [[h, e.uuid] for h in e_feed['Event'].pop('_hashes')]
    manifest.update(e_feed['Event'].pop('_manifest'))

    with open(os.path.join(outputdir, f'{event["uuid"]}.json'), 'w') as f:
        json.dump(event, f, indent=2)
    print("Event exported to {}".format(outputdir))

    with open(os.path.join(outputdir, 'manifest.json'), 'w') as manifest_file:
        manifest_file.write(json.dumps(manifest))
    print("Manifest saved to {}".format(outputdir))

    with open(os.path.join(outputdir, 'hashes.csv'), 'w') as hash_file:
        for element in hashes:
            hash_file.write('{},{}\n'.format(element[0], element[1]))
    print("Hashes saved. Feed creation completed.")

def get_attributes(mongo_client, time_delta_in_minutes):
    db = mongo_client['DockerHoneypot']

    start = datetime.now() - timedelta(minutes=int(time_delta_in_minutes))
    request_logs = db.http_request_log.find( {'Date': {'$gte': start}})

    attributes = {}

    for request in request_logs:

        data_json = request['DataJson']

        action = detect_action(request)
        dt = datetime.now().strftime("[%d/%m/%Y %H:%M:%S]")
        path = request['Path']
        source_ip = request['SourceIP']
        comment = None
        urls = []

        if action == 'docker_service_enumeration':
            comment = 'Docker service enumeration;'

        elif action == 'docker_containers_enumeration':
            comment = 'Docker containers enumeration;'

        elif action == 'docker_images_enumeration':
            comment = 'Docker images enumeration;'

        elif action == 'docker_containers_create':
            cmd = data_json.get('Cmd')
            if cmd:
                cmd = ' '.join(data_json.get('Cmd'))
                urls += extract_urls(cmd=cmd)

            entrypoint = data_json.get('Entrypoint')
            if entrypoint:
                entrypoint = ' '.join(entrypoint)
                urls += extract_urls(cmd=entrypoint)

            comment = 'Docker container creation attempt: Cmd:{} Entrypoint: {} Env: {};'.format(cmd, entrypoint, data_json.get('Env'))

        elif action == 'docker_images_create':
            image = 'Image: {} Tag: {}'.format(request['Args']['fromImage'], request['Args']['tag'])
            comment = 'Docker image creation attempt. {};'.format(image)

        elif action == 'docker_container_exec':
            cmd = data_json.get('Cmd')
            if cmd:
                cmd = ' '.join(data_json.get('Cmd'))
                urls += extract_urls(cmd=cmd)
            comment = 'Docker command execution attempt. Cmd: {};'.format(cmd)

        elif action =='docker_container_delete':
            comment = 'Docker container delete attempt.;'

        elif action == 'unhandled':
            pass

        if not comment or action == 'unhandled':
            continue

        if source_ip in attributes:
            if not comment in attributes[source_ip]['comment']:
                attributes[source_ip]['comment'] += comment
        else:
            attributes[source_ip] = {
                'type':'ip-src',
                'value':request['SourceIP'],
                'comment': comment
            }

        for url in list(set(urls)):
            attributes[url] = {
                'type':'url',
                'value':url,
                'to_ids':False
            }

    return attributes

def export_misp(misp, event_name, attributes):
    misp_event = get_misp_event(misp=misp, event_name=event_name)

    for key, attribute in attributes.items():
        misp.add_attribute(misp_event['id'], attribute, pythonify=True)

    print("Event exported")

def export_csv(filepath, event_name, attributes):
    with open(filepath, 'w') as csv_file:
        csv_file.write('value,type,comment\n')

        for key, attribute in attributes.items():
            csv_file.write('{},{},{}\n'.format(attribute.get('value'),attribute.get('type'),attribute.get('comment')))

    print("Event exported to {}".format(filepath))

def main():
    parser = argparse.ArgumentParser(description='Push detected IOCs to a MISP instance.')
    parser.add_argument('action', type=str, help="action: export_misp, export_csv, generate_misp_feed")
    parser.add_argument("-l", "--last", help="timedelta, can be defined minutes.")
    parser.add_argument("-e", "--event-name",  help="MISP event name to use", default='Docker honeypot (DockerTrap)')
    parser.add_argument("-d", "--output-dir",  help="Output directory to export feed")
    parser.add_argument("-f", "--csv-file",  help="File path to export csv")
    
    args = parser.parse_args()

    CURRENT_DIR = os.path.abspath(os.path.dirname(__file__))
    SETTINGS_PATH = os.path.join(CURRENT_DIR, 'settings', 'settings.yml')

    with open(SETTINGS_PATH) as f:
        settings = yaml.safe_load(f)

    misp_settings = settings['misp']
    misp = ExpandedPyMISP(misp_settings['url'], misp_settings['key'], misp_settings['verify'], cert=misp_settings['cert'])
    mongo_client = MongoClient(settings['mongodb']['uri'])
   
    if args.action == 'export_misp':
        attributes = get_attributes(mongo_client=mongo_client, time_delta_in_minutes=int(args.last))
        export_misp(misp=misp, event_name=args.event_name, attributes=attributes)

    elif args.action == 'export_csv':
        attributes = get_attributes(mongo_client=mongo_client, time_delta_in_minutes=int(args.last))
        export_csv(filepath=args.csv_file, event_name=args.event_name, attributes=attributes)

    elif args.action == 'generate_misp_feed':
        Path(args.output_dir).mkdir(parents=True, exist_ok=True)
        export_as_json_feed(misp=misp, event_name=args.event_name, outputdir=args.output_dir)

    
if __name__ == '__main__':

    if os.name == 'nt':
        main()
    else:
        get_lock("send_to_misp")
        call_with_timeout(main,(),{},60)
